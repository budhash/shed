#!/usr/bin/env bash
# --------------------------------------------------------------------
# {{app}} - {{detail}}
# 
# {{description}}
# --------------------------------------------------------------------
# AUTHOR: {{first}} {{last}} <{{email}}>
# VERSION: {{version}}
# LICENSE: {{license_name}}
# --------------------------------------------------------------------

##( configuration
set -eEuo pipefail; IFS=$'\n\t'  # fail fast, secure IFS
##) configuration

##( metadata
readonly __NAME=template
readonly __APP="$(basename "${BASH_SOURCE[0]:-}")"
__DBG=${DEBUG:-false}
##) metadata

##( dependencies
readonly __OS=(mac linux)
readonly __DEPS=(find)
##) dependencies

##( globals

##[ colors
_RST=$'\033[0m' _GRN=$'\033[0;32m' _YLW=$'\033[0;33m' _RED=$'\033[0;31m' _BLU=$'\033[0;34m'
[[ -n "${NO_COLOR:-}" || ! -t 1 ]] && _RST='' _GRN='' _YLW='' _RED='' _BLU=''
##] colors

##[ error
# general failure / bad usage / dependency not found / unsupported OS / not found / permission error / not connected
readonly _E=1 _E_USG=2 _E_DEP=3 _E_OS=4 _E_NF=5 _E_NP=6 _E_NC=7  
##] error

##) globals

##( helpers

##[ system
u.os() { case "${OSTYPE:-}" in darwin*) echo mac;; linux*) echo linux;; *) echo unknown;; esac; }
u.require() { command -v "${1:-}" >/dev/null || { u.error "missing dependency: ${1:-}"; exit $_E_DEP; }; }
u.die() { u.error "$@"; exit $_E; }
##] system

##[ logging
u.log() {
  local _l="info " _co="$_GRN"
  [[ "${1:-}" == "-l" ]] && { _l="${2:-info}"; shift 2; }
  case "$_l" in warn) _co="$_YLW";; error) _co="$_RED";; debug) _co="$_BLU"; [[ "$__DBG" != true ]] && return;; esac
  printf "${_co}[%s]${_RST} %s\n" "$_l" "$*" >&2
  return 0
}
u.info() { u.log -l "info " "$@"; }
u.warn() { u.log -l "warn " "$@"; }
u.error() { u.log -l "error" "$@"; }
u.debug() { u.log -l "debug" "$@"; }
##] logging

##) helpers

##( app

##[ config
readonly __APP_DEPS=(find)
##] config

##[ constants
##] constants

##[ functions
_main() {
  # Simple getopts-based argument parsing
  local _opt _help=false _version=false _file=""
  while getopts "hvf:" _opt; do
    case $_opt in
      h) _help=true;;
      v) _version=true;;
      f) _file="$OPTARG";;
      \?) u.error "unknown option: -${OPTARG:-}"; exit $_E_USG;;
    esac
  done
  shift $((OPTIND-1))

  [[ "$_help" == true ]] && { _help; exit 0; }
  [[ "$_version" == true ]] && { _version; exit 0; }
  
  local _primary_arg="${1:-}"
  
  u.info "Template version: $(_version) running on $(u.os)"
  [[ -n "$_file" ]] && u.info "File option: $_file"
  [[ -n "$_primary_arg" ]] && u.info "Primary argument: $_primary_arg"
  # Add your main application logic here
}

_help() {
  cat << EOF
$(_version) - {{detail}}

USAGE:
    $__APP [OPTIONS] [ARGUMENT]

OPTIONS:
    -h          Show help
    -v          Show version
    -f FILE     Process specified file

EXAMPLES:
    $__APP
    $__APP -f config.txt
    $__APP -f data.csv input_file
EOF
}

_version() { 
  sed -n 's/^# VERSION:[[:space:]]*\(.*\)/\1/p' "$__APPFILE" 2>/dev/null || echo "unknown"
}

_cleanup() { 
  u.debug "Cleanup"
}
##] functions

##) app

##( core
_boot() {
  local _source="${BASH_SOURCE[0]}"
  while [[ -h "$_source" ]]; do # resolve $_source until the file is no longer a symlink
    local _dir; _dir="$(cd -P "$(dirname "$_source")" && pwd)"
    _source="$(readlink "$_source")"
    [[ "$_source" != /* ]] && _source="$_dir/$_source"
  done

  readonly __APPDIR="$(cd -P "$(dirname "$_source")" && pwd)"
  readonly __APPFILE="${BASH_SOURCE[0]}"

  printf '%s\n' "${__OS[@]}" | grep -Fxq "$(u.os)" || u.die "unsupported OS: $(u.os) [required: ${__OS[*]}]"
  local _tool; for _tool in "${__APP_DEPS[@]:-}"; do u.require "$_tool"; done
}

trap _cleanup EXIT
if [[ "${BASH_SOURCE[0]:-}" == "${0}" ]]; then
  _boot
  _main "$@"
fi
##) core