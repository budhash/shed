#!/usr/bin/env bash
#
# Common Test Framework for shed tools
#
# Source this file from your tool's tests.sh:
# source ../.common/test-common

##( configuration
set -euo pipefail
##) configuration

##( globals
# Test framework globals
_TESTS_RUN=0
_FAILURES=0

# Colors (disable with NO_COLOR=1)
_RST=$'\033[0m' _GRN=$'\033[0;32m' _RED=$'\033[0;31m' _YLW=$'\033[1;33m' _BLU=$'\033[0;34m'
[[ -n "${NO_COLOR:-}" ]] && _RST='' _GRN='' _RED='' _YLW='' _BLU=''

# Tool info (auto-detected)
TOOL_NAME=${TOOL_NAME:-$(basename "$(pwd)")}
TOOL_SCRIPT=${TOOL_SCRIPT:-"./$TOOL_NAME"}
##) globals

##( test framework
# Main test runner - call this from your tests.sh
test_runner() {
  echo "Running Test Suite for $TOOL_NAME..."
  echo
  
  # Run standard tests first
  _test_standard_functionality
  
  # Run custom tests (defined in individual test files)
  if declare -f test_custom_functionality >/dev/null; then
    test_custom_functionality
  fi
  
  # Run any other test functions that start with test_ (but exclude test_runner and test_section)
  local func
  for func in $(declare -F | awk '/^declare -f test_/ {print $3}' | grep -v -E '^(test_runner|test_section|test_custom_functionality)$'); do
    if declare -f "$func" >/dev/null; then
      $func
    fi
  done
  
  echo
  echo "=================================="
  if [[ $_FAILURES -eq 0 ]]; then
    printf "%s (%d tests)\n" "${_GRN}✓ ALL TESTS PASSED${_RST}" "$_TESTS_RUN"
  else
    printf "%s (out of %d)\n" "${_RED}✗ $_FAILURES TESTS FAILED${_RST}" "$_TESTS_RUN"
  fi
  echo "=================================="
  
  exit $_FAILURES
}

# Print test section header
test_section() {
  local section_name="${1:-Unknown}"
  echo -e "${_BLU}Testing: $section_name${_RST}"
}

# Assertion: equality
assert_eq() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local expected="${1:-}" actual="${2:-}" desc="${3:-test}"
  if [[ "$expected" == "$actual" ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
    printf "    Expected: '%s'\n" "$expected"
    printf "    Actual:   '%s'\n" "$actual"
  fi
}

# Assertion: command succeeds
assert_ok() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local desc="${*: -1}"
  local cmd=("${@:1:$#-1}")
  
  if "${cmd[@]}" >/dev/null 2>&1; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}

# Assertion: command fails  
assert_fail() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local desc="${*: -1}"
  local cmd=("${@:1:$#-1}")
  
  set +e
  "${cmd[@]}" >/dev/null 2>&1
  local status=$?
  set -e
  
  if [[ $status -ne 0 ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}

# Assertion: string contains substring
assert_contains() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local haystack="${1:-}" needle="${2:-}" desc="${3:-test}"
  if [[ "$haystack" == *"$needle"* ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}

# Assertion: string matches regex
assert_matches() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local text="${1:-}" pattern="${2:-}" desc="${3:-test}"
  if [[ "$text" =~ $pattern ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}

# Assertion: file exists
assert_file_exists() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local file="${1:-}" desc="${2:-file exists}"
  if [[ -f "$file" ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}

# Assertion: directory exists
assert_dir_exists() {
  _TESTS_RUN=$((_TESTS_RUN + 1))
  local dir="${1:-}" desc="${2:-directory exists}"
  if [[ -d "$dir" ]]; then
    printf "  ${_GRN}✓${_RST} %s\n" "$desc"
  else
    _FAILURES=$((_FAILURES + 1))
    printf "  ${_RED}✗${_RST} %s\n" "$desc"
  fi
}
##) test framework

##( standard tests
# Standard tests that all tools should pass
_test_standard_functionality() {
  test_section "Standard Functionality"
  
  # Test if the main script exists and is executable
  assert_file_exists "$TOOL_SCRIPT" "script file exists"
  assert_ok test -x "$TOOL_SCRIPT" "script is executable"
  
  # Test help flag (try short flag first, then long flag)
  if $TOOL_SCRIPT -h >/dev/null 2>&1; then
    assert_ok $TOOL_SCRIPT -h "short help flag works"
  fi
  
  if $TOOL_SCRIPT --help >/dev/null 2>&1; then
    assert_ok $TOOL_SCRIPT --help "long help flag works"
  fi
  
  # Test version flag (try short flag first, then long flag)  
  if $TOOL_SCRIPT -v >/dev/null 2>&1; then
    assert_ok $TOOL_SCRIPT -v "short version flag works"
  fi
  
  if $TOOL_SCRIPT --version >/dev/null 2>&1; then
    assert_ok $TOOL_SCRIPT --version "long version flag works"
  fi
  
  # Test invalid option fails gracefully
  assert_fail $TOOL_SCRIPT --invalid-option "invalid option fails gracefully"
  
  echo
}
##) standard tests

##( helper functions
# Create a temporary directory for testing
make_temp_dir() {
  mktemp -d "${TMPDIR:-/tmp}/shed-test-${TOOL_NAME}-XXXXXX"
}

# Create a temporary file for testing
make_temp_file() {
  mktemp "${TMPDIR:-/tmp}/shed-test-${TOOL_NAME}-XXXXXX"
}

# Cleanup function for temp files
cleanup_temp() {
  local temp_path="$1"
  [[ -n "$temp_path" && "$temp_path" =~ shed-test ]] && rm -rf "$temp_path"
}
##) helper functions